! Copyright (c) 2015 Alberto Otero de la Roza <aoterodelaroza@gmail.com>,
! Ángel Martín Pendás <angel@fluor.quimica.uniovi.es> and Víctor Luaña
! <victor@fluor.quimica.uniovi.es>.
!
! critic2 is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or (at
! your option) any later version.
!
! critic2 is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

! Class for 3d grids and related tools.
module grid3mod
  use param, only: mlen
  implicit none

  private

  !> Information for QE Kohn-Sham states, maybe plus wannier functions
  type qedat
     integer :: nks !< Number of k-points (nk1*nk2*nk3)
     integer :: nk(3) !< Number of k-points in each grid direction (0 if not a grid)
     integer :: nbnd !< Number of bands
     integer :: nspin !< Number of spins
     logical :: gamma_only !< Whether gamma-only tricks are being used
     character(len=mlen) :: fpwc !< pwc file name
     real*8, allocatable :: kpt(:,:) !< k-points in cryst. coords. (3,k)
     real*8, allocatable :: wk(:) !< k-point weights (k)
     real*8, allocatable :: ek(:,:,:) !< band energies (bnd,k,spin)
     real*8, allocatable :: occ(:,:,:) !< band occupations (bnd,k,spin)
     integer, allocatable :: ngk(:) !< number of plane-waves for each k-point (k)
     integer, allocatable :: igk_k(:,:) !< fft reorder (npw,nk)
     integer, allocatable :: nl(:) !< fft reorder (ngms)
     integer, allocatable :: nlm(:) !< fft reorder (ngms) (gamma only)
     ! Wannier transformation
     integer :: nbndw(2) !< Number of occuped bands (for the Wannier transform)
     real*8, allocatable :: center(:,:,:) !< wannier function centers (cryst)
     real*8, allocatable :: spread(:,:) !< wannier function spreads (bohr)
     complex*16, allocatable :: u(:,:,:,:) !< u matrix
  end type qedat
  public :: qedat

  !> Three-dimensional grid class
  type grid3
     logical :: isinit = .false. !< is the grid initialized?
     logical :: isqe = .false. !< does it have qe ks states info?
     logical :: iswan = .false. !< does it have wannier info?
     integer :: mode !< interpolation mode
     integer :: n(3) !< number of grid points in each direction
     real*8, allocatable :: f(:,:,:) !< grid values
     real*8, allocatable :: c2(:,:,:,:) !< cubic coefficients for spline interpolation
     type(qedat) :: qe !< QE band states and Wannier function transformation
   contains
     procedure :: end => grid_end !< deallocate all arrays and uninitialize
     procedure :: setmode !< set the interpolation mode of a grid
     procedure :: normalize !< normalize the grid to a given value
     procedure :: from_array3 !< build a grid3 from a 3d array of real numbers
     procedure :: read_cube !< grid3 from a Gaussian cube file
     procedure :: read_bincube !< grid3 from a binary cube file
     procedure :: read_siesta !< grid3 from siesta RHO file
     procedure :: read_abinit !< grid3 from abinit binary file
     procedure :: read_vasp !< grid3 from VASP file (CHG, CHGCAR, etc.)
     procedure :: read_qub !< grid3 from aimpac qub format
     procedure :: read_xsf !< grid3 from xsf (xcrysden) file
     procedure :: read_pwc !< read a pwc file created by pw2critic.x
     procedure :: read_elk !< grid3 from elk file format
     procedure :: read_wannier_chk !< qe/wannier info from chk file
     procedure :: interp !< interpolate the grid at an arbitrary point
     procedure :: laplacian_hxx !< grid3 as the Laplacian or Hessian diagonal of another grid3
     procedure :: pot !< grid3 as the potential generated by another grid3
     procedure :: gradrho !< grid3 as the gradrho of another grid3
     procedure :: resample !< grid3 as a Fourier resampling of another grid3
     procedure :: rotate_qe_evc !< write U-rotated scratch files using QE evc file
     procedure :: get_qe_wnr !< build a Wannier function from Bloch coeffs (pre-open, parallel)
     procedure :: get_qe_wnr_standalone !< build a Wannier function from Bloch coeffs (standalone)
     procedure :: get_qe_psink_standalone !< build a psink(r) function from Bloch coeffs (standalone)
     procedure :: new_eval !< grid3 from an arithmetic expression
  end type grid3
  public :: grid3

  integer, parameter :: mode_nearest = 1 !< interpolation mode: nearest grid node
  integer, parameter :: mode_trilinear = 2 !< interpolation mode: trilinear
  integer, parameter :: mode_trispline = 3 !< interpolation mode: trispline
  integer, parameter :: mode_tricubic = 4 !< interpolation mode: tricubic
  integer, parameter :: mode_default = mode_tricubic

  interface
     module subroutine new_eval(f,sptr,n,expr)
       use iso_c_binding, only: c_ptr
       class(grid3), intent(inout) :: f
       type(c_ptr), intent(in) :: sptr
       integer, intent(in) :: n(3)
       character(*), intent(in) :: expr
     end subroutine new_eval
     module subroutine grid_end(f)
       class(grid3), intent(inout) :: f
     end subroutine grid_end
     module subroutine setmode(f,mode)
       class(grid3), intent(inout) :: f
       character*(*), intent(in) :: mode
     end subroutine setmode
     module subroutine normalize(f,norm,omega)
       class(grid3), intent(inout) :: f
       real*8, intent(in) :: norm, omega
     end subroutine normalize
     module subroutine from_array3(f,g)
       class(grid3), intent(inout) :: f
       real*8, intent(in) :: g(:,:,:)
     end subroutine from_array3
     module subroutine read_cube(f,file)
       class(grid3), intent(inout) :: f
       character*(*), intent(in) :: file !< Input file
     end subroutine read_cube
     module subroutine read_bincube(f,file)
       class(grid3), intent(inout) :: f
       character*(*), intent(in) :: file !< Input file
     end subroutine read_bincube
     module subroutine read_siesta(f,file)
       class(grid3), intent(inout) :: f
       character*(*), intent(in) :: file !< Input file
     end subroutine read_siesta
     module subroutine read_abinit(f,file)
       class(grid3), intent(inout) :: f
       character*(*), intent(in) :: file !< Input file
     end subroutine read_abinit
     module subroutine read_vasp(f,file,omega,ibl)
       class(grid3), intent(inout) :: f
       character*(*), intent(in) :: file !< Input file
       real*8, intent(in) :: omega !< Cell volume
       integer, intent(in), optional :: ibl !< grid block to read
     end subroutine read_vasp
     module subroutine read_qub(f,file)
       class(grid3), intent(inout) :: f
       character*(*), intent(in) :: file !< Input file
     end subroutine read_qub
     module subroutine read_xsf(f,file)
       class(grid3), intent(inout) :: f
       character*(*), intent(in) :: file !< Input file
     end subroutine read_xsf
     module subroutine read_pwc(f,fpwc,ispin,ikpt,ibnd,emin,emax)
       class(grid3), intent(inout) :: f
       character*(*), intent(in) :: fpwc !< Input file (pwc file from QE)
       integer, intent(in) :: ispin
       integer, intent(in), allocatable :: ikpt(:)
       integer, intent(in), allocatable :: ibnd(:)
       real*8, intent(in) :: emin, emax
     end subroutine read_pwc
     module subroutine read_elk(f,file)
       class(grid3), intent(inout) :: f
       character*(*), intent(in) :: file !< Input file
     end subroutine read_elk
     module subroutine read_wannier_chk(f,fileup,filedn)
       class(grid3), intent(inout) :: f
       character*(*), intent(in) :: fileup
       character*(*), intent(in), optional :: filedn
     end subroutine read_wannier_chk
     module subroutine interp(f,xi,y,yp,ypp)
       class(grid3), intent(inout) :: f !< Grid to interpolate
       real*8, intent(in) :: xi(3) !< Target point (cryst. coords.)
       real*8, intent(out) :: y !< Interpolated value
       real*8, intent(out) :: yp(3) !< First derivative
       real*8, intent(out) :: ypp(3,3) !< Second derivative
     end subroutine interp
     module subroutine laplacian_hxx(flap,frho,x2c,ix)
       class(grid3), intent(inout) :: flap
       type(grid3), intent(in) :: frho
       real*8, intent(in) :: x2c(3,3)
       integer, intent(in) :: ix
     end subroutine laplacian_hxx
     module subroutine gradrho(fgrho,frho,x2c)
       class(grid3), intent(inout) :: fgrho
       type(grid3), intent(in) :: frho
       real*8, intent(in) :: x2c(3,3)
     end subroutine gradrho
     module subroutine pot(fpot,frho,x2c,isry)
       class(grid3), intent(inout) :: fpot
       type(grid3), intent(in) :: frho
       real*8, intent(in) :: x2c(3,3)
       logical, intent(in) :: isry
     end subroutine pot
     module subroutine resample(frs,frho,n2)
       class(grid3), intent(inout) :: frs
       type(grid3), intent(in) :: frho
       integer, intent(in) :: n2(3)
     end subroutine resample
     module subroutine rotate_qe_evc(f,luevc,luevc_ibnd,useu)
       class(grid3), intent(inout) :: f
       integer, intent(out) :: luevc(2)
       integer, intent(out) :: luevc_ibnd(2)
       logical, intent(in) :: useu
     end subroutine rotate_qe_evc
     module subroutine get_qe_wnr(f,omega,ibnd,ispin,luevc,luevc_ibnd,fout)
       class(grid3), intent(in) :: f
       real*8, intent(in) :: omega
       integer, intent(in) :: ibnd
       integer, intent(in) :: ispin
       integer, intent(in) :: luevc(2)
       integer, intent(inout) :: luevc_ibnd(2)
       complex*16, intent(out) :: fout(:,:,:,:)
     end subroutine get_qe_wnr
     module subroutine get_qe_wnr_standalone(f,omega,ibnd,ispin,inr,rotate,fout)
       class(grid3), intent(in) :: f
       real*8, intent(in) :: omega
       integer, intent(in) :: ibnd
       integer, intent(in) :: ispin
       integer, intent(in) :: inr(3)
       logical, intent(in) :: rotate
       complex*16, intent(out) :: fout(:,:,:)
     end subroutine get_qe_wnr_standalone
     module subroutine get_qe_psink_standalone(f,omega,ibnd,ik,ispin,usephase,inr,fout)
       class(grid3), intent(in) :: f
       real*8, intent(in) :: omega
       integer, intent(in) :: ibnd
       integer, intent(in) :: ik
       integer, intent(in) :: ispin
       logical :: usephase
       integer, intent(in) :: inr(3)
       complex*16, intent(out) :: fout(:,:,:)
     end subroutine get_qe_psink_standalone
  end interface

end module grid3mod
